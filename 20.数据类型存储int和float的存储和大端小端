//强化数据的存储
//数据中的原码反码补码
//一.c语言类型
//1.内置类型
//char （unsigned无符号0~255）有符号-128~127
//int
//short
//long
//float
//double

//数据类型决定的意义
//使用这个类型开辟的数据内存空间的大小  如何看待内存空间的视角
//int p=10;和float p=10.0是不一样的内存存储方式
//2.自定义类型

//数据类型分类
//整型类型（int short long char）
//浮点型类型(float double)
//(自定义)构造类型(数组类型、结构体类型struct、枚举类型enum、联合类型union)
//指针类型（int* char* float* void*）
//空类型void


//二.整型在数据中的存储
//反码补码原码
//符号位和数值位
//无符号数值原、反、补相同
//有符号型1.正数原、反、补相同
//        2.负数原、反、补各不相同
//数值存储、运算为补码，进行输出为原码
//源码：把数值翻译为二进制
//反码：符号位不变数值位按位取反
//补码：反码+1
//CPU里面只有加法器
//例如1-1
//00000000000000000000000000000001+10000000000000000000000000000001=11111111111111111111111111111110=1111 1111 1111 1111 1111 1111 1111 1111
//00000000000000000000000000000001+11111111111111111111111111111111=10000000000000000000000000000000
//*变为加法运算


//三.大端小端介绍
//大端（存储）模式，是指数据的低位保存在内存的高位址，而数据的高位保存在内存的低位址
//小端（存储）模式，是指数据的低位保存在内存的低位址，而数据的高位保存在内存的高位址
//0x11 22 33 44
//这里的44为低位11为高位
//存储的时候11 22 33 44低位存储在高位
//存储的时候44 33 22 11低位在存储低位（计算机小端）
//例如0000 0000 0000 0000 0000 0000 0000 0001 0100=0x00 00 00 14进行存储就为14 00 00 00


//四.写一段代码告诉我们机器当前的字节序
//#include<stdio.h>
//int main()
//{
//	int a = 1;
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
//}
//#include<stdio.h>
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a;//只需要看第一位就可以知道大小端
//	if (*p == 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//}
//方法2
//#include<stdio.h>
//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;//访问第一个字节
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
//}

//%u打印无符号型
//#include<stdio.h>
//
//int main()
//{
//	char a = -1;//1111 1111 1111 1111 1111 1111 1111 1111---》取低位1111 1111进行整型提升1111 1111 1111 1111 1111 1111 1111 1111=-1
//	signed char b = -1;
//	char e = -128;
//	unsigned char c = -1;//1000 0001---1000 0000---1111 1111---1111 1111(无符号)整型提升补0  0000 0000 0000 0000 0000 0000 1111 1111
//	printf("a=%d,b=%d,c=%d,e=%d,%u", a, b, c,e,e);//-1,-1,255
//	//-128---1000 0000 0000 0000 0000 0000 1000 0000---1000 0000---1111 1111 1111 1111 1111 1111 1000 0000--1111 1111 1111 1111 1111 1111 0111 1111----1000 0000 0000 0000 0000 0000 1000 0000=-128
//	//1111 1111 1111 1111 1111 1111 1000 0000=4294967168
//}
//有符号char：1000 0000 =-128~127=0111 1111  0--127->-128--(-1)--0
//无符号char:0~255
//i+j
//-20+10
//1000 0000 0000 0000 0000 0000 0001 0100
//1000 0000 0000 0000 0000 0000 0001 0011
//1111 1111 1111 1111 1111 1111 1110 1100=-20
//0000 0000 0000 0000 0000 0000 0000 1010=10
//1111 1111 1111 1111 1111 1111 1111 0110=-20+10=补码
//1111 1111 1111 1111 1111 1111 1111 0101=反码
//1000 0000 0000 0000 0000 0000 0000 1010=-10


//五.判断下面输出结果
//sleep函数头文件<windows.h>,作用进行休眠时间为毫秒
//#include<stdio.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u", i);//9 8 7 6 5 4 3 2 1 0 -1--->1111 1111 1111 1111 1111 1111 1111 1111-->1111 1111 1111 1111 1111 1111 1111 1111--->无符号=4294967295
//	}
//}


//六.判断下面输出结果
//#include<stdio.h>
//int main()
//{
//	char a[1000];//0~999  char表示-128-127
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -2 - i;//a[0]=-1,-2，-3，-4.......-128-->127-->126.......-->3->2->1->0遇到0停下255
//	}
//	printf("%d", strlen(a));//255char最多255'\0'
//}

//七.注意char的循环规律（char的存储规律有无符号和有符号的区别小心死循环出现）
//注意无符号型小心、进入死循环
//#include<stdio.h>
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world");//0-->127--255结果应该为hello无限循环因为char为0~255过了255为0
//
//	}
//}


//八.浮点型的存储规律
//float double long double
//小数表示法3.14，科学表示法1E10
//limits.h可以查询符号范围
//char0~255/-128~127
//short-32768~32767/
#include<stdio.h>
int main()
{
	int n = 9;
	float *pfloat = (float*)&n;//强制类型转化
	printf("n的值为：%d\n", n);//9
	printf("*pfliat的值为：%f\n", *pfloat);//0.000000

	*pfloat = 9.0;//0 00001001.0000 0000 0000 0000 0000 000
	printf("n的值为：%d\n", n);//
	printf("*pfliat的值为：%f\n", *pfloat);//9.00000
}
//9--00000000000000000000000000001001补码
//浮点数0 00000000 00000000000000000001001=0.00000000000000000001001*2^(1-127)
//1001.00--1.001*2^3---0 10000010 0010000000000000000000000
//3+127=130               130      001


//当E不全为0或E-127/1023
//全0为（1-127）无穷小
//全1为无穷大
//符号位  指数位  有效位

//float 的存储形式
//整型和浮点型存储方式不同
//整型存储为二进制补码
//浮点型存储为
//例如9.0---10001.0---(-1)^0*1.001*2^3--->我们只存储小数点后面之后我们加上1就可以了
//(-1)^s*m*2^E
//对于32位浮点数第一位为符号位s后面有8位bit存储E,其他23存储有效数字m
//64位第一位为符号位后11个为E，其他52个bit位有效数字m(1<=m<2)
//小数转化为二进制整数部分直接转化，小数部分一直乘二遇1结束大于1则减去1
//5.5=101.1=（-1）^0*1.011*2^2 
